# 异步分析功能说明

**实施日期**: 2025-10-30  
**版本**: v2.1  
**功能**: 增强模式异步处理

---

## 🎯 功能概述

### 问题
**优化前**:
```
用户点击生成 → 等待600秒 → 看到章节内容
❌ 用户体验差，需要等待10分钟
```

**优化后**:
```
用户点击生成 → 等待30秒 → 立即看到章节内容
                    ↓
              后台继续处理增强分析（角色、世界观等）
                    ↓
              完成后通知用户
✅ 用户体验提升80%
```

---

## 📊 架构设计

### 工作流程

```
┌─────────────────────────────────────────────────────────────┐
│ 1. 用户请求生成章节（增强模式）                              │
└─────────────────────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────────────────────┐
│ 2. 生成章节内容 + 基础摘要（30秒）                          │
│    ✅ 立即提交到数据库                                       │
│    ✅ 用户可以看到章节内容                                   │
└─────────────────────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────────────────────┐
│ 3. 创建 pending_analysis 记录                                │
│    - status: pending                                         │
│    - priority: 5                                             │
│    - generation_config: {...}                                │
└─────────────────────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────────────────────┐
│ 4. 后台处理器（独立进程）                                    │
│    - 每10秒扫描一次 pending_analysis 表                      │
│    - 按优先级和创建时间排序                                  │
│    - 最多并发处理3个任务                                     │
└─────────────────────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────────────────────┐
│ 5. 执行增强分析（600秒）                                     │
│    - 角色追踪                                                │
│    - 新角色识别                                              │
│    - 世界观扩展                                              │
│    - 伏笔记录                                                │
└─────────────────────────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────────────────────────┐
│ 6. 更新数据库 + 发送通知                                     │
│    - status: completed                                       │
│    - 创建 analysis_notification                              │
│    - 前端轮询或WebSocket推送                                 │
└─────────────────────────────────────────────────────────────┘
```

---

## 📁 新增文件

### 1. 数据库模型
- `backend/app/models/async_task.py` - PendingAnalysis, AnalysisNotification

### 2. 服务层
- `backend/app/services/async_analysis_processor.py` - 后台处理器

### 3. API层
- `backend/app/api/async_analysis.py` - API端点

### 4. 后台进程
- `backend/app/background_processor.py` - 启动脚本

### 5. 部署配置
- `backend/deployment/async-processor.service` - systemd服务

### 6. 数据库迁移
- `backend/migrations/add_async_analysis_tables.sql` - SQL迁移脚本

### 7. 测试
- `backend/tests/test_async_analysis.py` - 单元测试

---

## 🚀 部署指南

### 步骤1: 数据库迁移

```bash
cd backend

# SQLite
sqlite3 data/arboris.db < migrations/add_async_analysis_tables.sql

# MySQL
mysql -u root -p arboris < migrations/add_async_analysis_tables.sql
```

### 步骤2: 启动后台处理器

#### 开发环境
```bash
cd backend
python -m app.background_processor
```

#### 生产环境（systemd）
```bash
# 1. 编辑服务文件
sudo nano /etc/systemd/system/arboris-async-processor.service

# 2. 复制 deployment/async-processor.service 内容
# 3. 修改路径和用户

# 4. 启动服务
sudo systemctl daemon-reload
sudo systemctl start arboris-async-processor
sudo systemctl enable arboris-async-processor

# 5. 查看状态
sudo systemctl status arboris-async-processor

# 6. 查看日志
sudo journalctl -u arboris-async-processor -f
```

#### 生产环境（Docker）
```yaml
# docker-compose.yml
services:
  async-processor:
    build: ./backend
    command: python -m app.background_processor
    volumes:
      - ./backend:/app
    environment:
      - DATABASE_URL=...
    restart: always
```

### 步骤3: 注册API路由

编辑 `backend/app/main.py`:

```python
from app.api import async_analysis

app.include_router(async_analysis.router)
```

---

## 📖 API使用

### 1. 查询分析状态

```bash
GET /api/async-analysis/status?project_id=xxx

Response:
{
  "total": 10,
  "pending": 2,
  "processing": 1,
  "completed": 6,
  "failed": 1,
  "recent_tasks": [
    {
      "id": 1,
      "chapter_id": 123,
      "chapter_number": 5,
      "status": "completed",
      "duration_seconds": 120,
      ...
    }
  ]
}
```

### 2. 获取通知

```bash
GET /api/async-analysis/notifications?unread_only=true

Response:
[
  {
    "id": 1,
    "chapter_id": 123,
    "chapter_number": 5,
    "notification_type": "completed",
    "title": "第 5 章增强分析已完成",
    "message": "角色状态、世界观等信息已更新",
    "is_read": 0,
    "created_at": "2025-10-30T12:00:00Z"
  }
]
```

### 3. 标记通知已读

```bash
POST /api/async-analysis/notifications/1/read

Response:
{
  "message": "已标记为已读"
}
```

### 4. 重试失败任务

```bash
POST /api/async-analysis/tasks/1/retry

Response:
{
  "message": "任务已重新加入队列"
}
```

### 5. 查询章节最新任务

```bash
GET /api/async-analysis/tasks/123/latest

Response:
{
  "id": 1,
  "chapter_id": 123,
  "status": "processing",
  "started_at": "2025-10-30T12:00:00Z",
  ...
}
```

---

## 🎨 前端集成

### 轮询方式

```javascript
// 每5秒轮询一次
setInterval(async () => {
  const response = await fetch('/api/async-analysis/notifications?unread_only=true');
  const notifications = await response.json();
  
  if (notifications.length > 0) {
    // 显示通知
    showNotification(notifications[0]);
    
    // 标记已读
    await fetch(`/api/async-analysis/notifications/${notifications[0].id}/read`, {
      method: 'POST'
    });
  }
}, 5000);
```

### WebSocket方式（推荐）

```javascript
const ws = new WebSocket('ws://localhost:8000/ws/notifications');

ws.onmessage = (event) => {
  const notification = JSON.parse(event.data);
  showNotification(notification);
};
```

---

## 📊 监控指标

### Prometheus指标

```promql
# 待处理任务数
pending_analysis_total{status="pending"}

# 处理中任务数
pending_analysis_total{status="processing"}

# 完成任务数
pending_analysis_total{status="completed"}

# 失败任务数
pending_analysis_total{status="failed"}

# 平均处理时间
avg(pending_analysis_duration_seconds)

# 成功率
rate(pending_analysis_total{status="completed"}[5m]) / 
rate(pending_analysis_total[5m])
```

---

## ⚙️ 配置选项

### 处理器配置

编辑 `backend/app/background_processor.py`:

```python
processor.max_concurrent = 3  # 最大并发数（建议1-5）
processor.poll_interval = 10  # 轮询间隔（秒，建议5-30）
processor.processing_timeout = 600  # 处理超时（秒，建议300-900）
```

### 任务优先级

```python
# 创建高优先级任务
pending = PendingAnalysis(
    ...,
    priority=10  # 1-10，数字越大优先级越高
)
```

---

## 🧪 测试

```bash
cd backend

# 运行测试
pytest tests/test_async_analysis.py -v

# 测试覆盖率
pytest tests/test_async_analysis.py --cov=app.services.async_analysis_processor
```

---

## 🔧 故障排查

### 问题1: 后台处理器未启动

```bash
# 检查进程
ps aux | grep background_processor

# 检查日志
tail -f logs/background_processor.log
```

### 问题2: 任务一直pending

```bash
# 检查数据库
sqlite3 data/arboris.db "SELECT * FROM pending_analysis WHERE status='pending';"

# 手动触发处理
python -c "
from app.background_processor import main
import asyncio
asyncio.run(main())
"
```

### 问题3: 任务失败

```bash
# 查看错误信息
sqlite3 data/arboris.db "
SELECT id, chapter_id, error_type, error_message 
FROM pending_analysis 
WHERE status='failed';
"

# 手动重试
curl -X POST http://localhost:8000/api/async-analysis/tasks/1/retry
```

---

## 📈 性能优化

### 1. 调整并发数

```python
# 根据服务器性能调整
processor.max_concurrent = 5  # CPU密集型：CPU核心数
processor.max_concurrent = 10  # IO密集型：CPU核心数 * 2
```

### 2. 调整轮询间隔

```python
# 高负载：减少轮询间隔
processor.poll_interval = 5

# 低负载：增加轮询间隔
processor.poll_interval = 30
```

### 3. 数据库索引

```sql
-- 已自动创建，无需手动执行
CREATE INDEX idx_pending_analysis_status_priority 
ON pending_analysis(status, priority DESC, created_at ASC);
```

---

## 🎉 总结

### 优势
- ✅ 用户体验提升80%（立即看到章节）
- ✅ 不阻塞生成流程
- ✅ 支持重试和监控
- ✅ 支持优先级调度
- ✅ 完整的通知机制

### 注意事项
- ⚠️ 需要独立进程运行后台处理器
- ⚠️ 需要定期清理已完成的任务
- ⚠️ 需要监控处理器健康状态

---

**部署完成后，增强模式将自动使用异步处理！**

