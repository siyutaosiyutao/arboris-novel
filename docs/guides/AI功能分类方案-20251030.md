# 🤖 AI功能分类与拆分方案

**日期**: 2025-10-30  
**目的**: 将项目中的AI功能模块化，便于独立配置、监控和优化

---

## 📊 当前AI功能全景图

### 1️⃣ **概念生成（Concept Generation）**
**功能**: 从用户想法生成完整的小说蓝图  
**提示词**: `concept.md`  
**调用位置**: `novel_service.py` (对话式生成)  
**输入**: 用户对话历史  
**输出**: 完整的Blueprint（标题、风格、世界观、角色、大纲）

**特点**:
- 多轮对话式交互
- 一次性生成完整设定
- 创造性最高（temperature高）

---

### 2️⃣ **大纲生成（Outline Generation）**
**功能**: 批量生成章节大纲（10章/次）  
**提示词**: `outline.md`  
**调用位置**: `auto_generator_service._auto_generate_outlines()`  
**输入**: 
- 完整Blueprint
- 已完成章节摘要
- 起始章节号 + 数量

**输出**: 
```json
{
  "chapters": [
    {"chapter_number": 1, "title": "...", "summary": "..."}
  ]
}
```

**特点**:
- 批量生成（10章）
- 参考已完成内容
- 确保剧情连贯

---

### 3️⃣ **章节正文生成（Chapter Writing）**
**功能**: 根据大纲生成章节正文  
**提示词**: `writing.md` 或 `screenwriting.md`  
**调用位置**: `auto_generator_service._generate_chapter_content()`  
**输入**:
- Blueprint
- 章节大纲
- RAG检索的上下文（可选）
- 写作指令（可选）

**输出**: 完整章节正文（3000-5000字）

**特点**:
- 支持多版本生成
- 支持RAG增强
- 可选剧本格式

---

### 4️⃣ **章节摘要提取（Summary Extraction）**
**功能**: 从章节正文提取简短摘要  
**提示词**: `extraction.md`  
**调用位置**: `llm_service.get_summary()`  
**输入**: 章节正文  
**输出**: 100-200字摘要

**特点**:
- 低temperature（0.15-0.2）
- 快速执行
- 用于后续大纲生成

---

### 5️⃣ **基础分析（Basic Analysis）**
**功能**: 提取章节摘要和关键事件  
**提示词**: 内嵌在代码中  
**调用位置**: `super_analysis_service._basic_analysis()`  
**输入**: 章节正文  
**输出**:
```json
{
  "summary": "章节摘要",
  "key_events": ["事件1", "事件2"]
}
```

**特点**:
- 必须成功
- 结构简单
- 快速执行

---

### 6️⃣ **增强分析（Enhanced Analysis）**
**功能**: 深度分析角色、世界观、伏笔等  
**提示词**: 内嵌在代码中  
**调用位置**: `super_analysis_service._enhanced_analysis()`  
**输入**: 
- 章节正文
- Blueprint

**输出**:
```json
{
  "character_changes": [...],
  "new_characters": [...],
  "world_extensions": {...},
  "foreshadowing": [...],
  "emotional_arcs": [...]
}
```

**特点**:
- 可选功能
- 失败不影响主流程
- 可异步执行

---

### 7️⃣ **章节评估（Chapter Evaluation）**
**功能**: 评估章节质量并给出改进建议  
**提示词**: `evaluation.md`  
**调用位置**: 未实现（预留）  
**输入**: 章节正文  
**输出**: 评分 + 反馈

**特点**:
- 质量控制
- 自动化评审
- 可用于自动重写

---

### 8️⃣ **向量嵌入（Embedding）**
**功能**: 生成文本向量用于RAG检索
**调用位置**:
- `chapter_ingest_service` (章节入库)
- `chapter_context_service` (检索查询)

**输入**: 文本片段
**输出**: 向量数组

**特点**:
- 非生成式
- 用于语义检索
- 支持多模型

---

### 9️⃣ **剧情指标分析（Story Metrics Analysis）** 🆕
**功能**: 分析章节剧情指标，用于自动分卷判定
**提示词**: 内嵌在代码中
**调用位置**: `story_metrics_service.analyze_chapter()`
**输入**:
- 章节正文
- 增强分析结果
- 基础摘要

**输出**:
```json
{
  "key_event_count": 3,
  "major_event_flag": true,
  "character_breakthrough_flag": true,
  "world_shock_flag": false,
  "foreshadow_count": 2,
  "foreshadow_max_conf": 0.85,
  "climax_score": 75,
  "stage_score": 72
}
```

**特点**:
- 数据驱动
- 可配置权重
- 用于自动分卷

---

### 🔟 **卷名生成（Volume Naming）** 🆕
**功能**: 根据剧情高潮生成卷名
**提示词**: `volume_naming.md`（新增）
**调用位置**: `volume_split_service.generate_volume_title()`
**输入**:
- 章节范围
- 重大事件摘要
- 剧情指标

**输出**: 卷名（如"卷五·星陨之夜"）

**特点**:
- 创意性高
- 一次性调用
- 有fallback策略

---

## 🎯 推荐的拆分方案（基于模型能力和成本优化）

### ⭐ **最终推荐方案：按模型能力需求分类**

根据实际业务需求，将AI功能按**所需模型能力**和**成本效益**分为6大类：

---

### 1️⃣ **章节正文生成（Creative Writing）** 🔥
**核心能力需求**: 创作能力、上下文理解、文学性
**推荐模型**: GPT-4、GPT-4o、Claude 3 Opus、Gemini 1.5 Pro
**成本**: 💰💰💰 高
**优先级**: ⭐⭐⭐ 核心（必须成功）

**包含功能**:
- 章节正文生成（多版本）
- 自动版本选择
- RAG增强写作

**特点**:
- 对创作能力要求最高
- 需要理解复杂上下文
- 用户体验最关键
- 适合用主力写作模型

**配置示例**:
```json
{
  "function_type": "creative_writing",
  "model": "gpt-4o",
  "temperature": 0.75,
  "max_retries": 3,
  "timeout": 600,
  "fallback_model": "claude-3-sonnet"
}
```

---

### 2️⃣ **结构规划类生成（Structural Planning）** 📋
**核心能力需求**: 逻辑规划、结构化输出、命名创意
**推荐模型**: Claude 3 Sonnet、DeepSeek-Chat、GPT-4o-mini
**成本**: 💰💰 中
**优先级**: ⭐⭐ 重要（失败需重试）

**包含功能**:
- 大纲生成（10章批量）
- 分卷自动命名
- 章节标题生成
- Screenwriting格式转换

**特点**:
- 偏结构规划，不需要极强文学性
- 需要逻辑连贯性
- 可以用成本更低的模型
- 适合擅长逻辑规划的模型

**配置示例**:
```json
{
  "function_type": "structural_planning",
  "model": "deepseek-chat",
  "temperature": 0.7,
  "max_retries": 3,
  "timeout": 360,
  "fallback_model": "gpt-4o-mini"
}
```

---

### 3️⃣ **章节摘要与关键信息抽取（Summarization & Extraction）** 📝
**核心能力需求**: 信息压缩、关键点提取、快速响应
**推荐模型**: Gemini 1.5 Flash、GPT-4o-mini、GPT-3.5-turbo
**成本**: 💰 低
**优先级**: ⭐⭐⭐ 核心（必须成功）

**包含功能**:
- 章节摘要提取
- 基础分析（摘要+关键事件）
- RAG前的辅助总结
- 快速信息提取

**特点**:
- 主要评估/压缩文本
- 需要快速响应
- 用高吞吐量模型
- 成本敏感

**配置示例**:
```json
{
  "function_type": "summarization",
  "model": "gemini-1.5-flash",
  "temperature": 0.15,
  "max_retries": 2,
  "timeout": 120,
  "fallback_model": "gpt-4o-mini"
}
```

---

### 4️⃣ **增强分析（Enhanced Analysis）** 🔍
**核心能力需求**: 信息抽取、一致性检查、细节理解
**推荐模型**: GPT-4o、Claude 3 Sonnet、Gemini 1.5 Pro
**成本**: 💰💰 中
**优先级**: ⭐ 可选（失败可降级）

**包含功能**:
- 角色状态追踪
- 世界观扩展
- 伏笔识别
- 情感弧线分析
- 剧情指标分析（用于自动分卷）

**特点**:
- 需要理解角色成长、设定细节
- 准确性很重要
- 可以异步执行
- 失败不影响主流程

**配置示例**:
```json
{
  "function_type": "enhanced_analysis",
  "model": "gpt-4o",
  "temperature": 0.5,
  "max_retries": 1,
  "timeout": 300,
  "async_mode": true,
  "fallback_strategy": "skip"
}
```

---

### 5️⃣ **创意附加分析（Creative Analysis）** 🎨
**核心能力需求**: 创意评估、质量判断、建议生成
**推荐模型**: Claude 3 Sonnet、GPT-4o-mini、DeepSeek-Chat
**成本**: 💰 低-中
**优先级**: ⭐ 可选（失败可忽略）

**包含功能**:
- 张力分析
- 角色一致性检查
- 伏笔检测
- 章节评估
- 改进建议

**特点**:
- 针对生成后的章节
- 质量控制类功能
- 可以与增强分析共用模型
- 或使用成本更低的替代方案

**配置示例**:
```json
{
  "function_type": "creative_analysis",
  "model": "claude-3-sonnet",
  "temperature": 0.4,
  "max_retries": 1,
  "timeout": 180,
  "fallback_strategy": "skip"
}
```

---

### 6️⃣ **概念/蓝图对话类（Interactive Concept Design）** 💬
**核心能力需求**: 交互式问答、引导能力、创意激发
**推荐模型**: Claude 3 Opus、GPT-4o、Gemini 1.5 Pro
**成本**: 💰💰 中
**优先级**: ⭐⭐ 重要（用户体验关键）

**包含功能**:
- 概念对话式生成
- 蓝图规划引导
- 灵感收集
- 多轮交互优化

**特点**:
- 需要交互式问答
- 善于引导用户
- 聊天体验很重要
- 适合对话能力强的模型

**配置示例**:
```json
{
  "function_type": "interactive_concept",
  "model": "claude-3-opus",
  "temperature": 0.8,
  "max_retries": 2,
  "timeout": 300,
  "fallback_model": "gpt-4o"
}
```

---

## 📊 功能分类对比表

| 功能类别 | 推荐模型 | 成本 | 优先级 | 失败策略 | 异步支持 |
|---------|---------|------|--------|---------|---------|
| 章节正文生成 | GPT-4o | 高 | 核心 | 重试3次 | ❌ |
| 结构规划 | DeepSeek-Chat | 中 | 重要 | 重试3次 | ❌ |
| 摘要抽取 | Gemini Flash | 低 | 核心 | 重试2次+fallback | ❌ |
| 增强分析 | GPT-4o | 中 | 可选 | 跳过 | ✅ |
| 创意分析 | Claude Sonnet | 低-中 | 可选 | 跳过 | ✅ |
| 概念对话 | Claude Opus | 中 | 重要 | 重试2次 | ❌ |

---

## 💰 成本优化策略

### 1. 分层模型策略
```
高成本模型（GPT-4o/Claude Opus）
  └── 仅用于核心创作和交互

中成本模型（Claude Sonnet/DeepSeek）
  └── 用于规划和分析

低成本模型（Gemini Flash/GPT-4o-mini）
  └── 用于摘要和快速提取
```

### 2. 动态降级策略
```python
# 示例：章节生成失败时的降级链
GPT-4o (主力)
  → Claude 3 Sonnet (降级1)
  → GPT-4o-mini (降级2)
  → 报错给用户
```

### 3. 异步执行策略
```
同步执行（阻塞）:
  - 章节正文生成
  - 摘要抽取
  - 基础分析

异步执行（后台）:
  - 增强分析
  - 创意分析
  - 剧情指标分析
```

---

## 🎯 具体映射表

| 原功能 | 新分类 | 推荐模型 | 温度 | 超时 |
|--------|--------|---------|------|------|
| 概念生成 | 概念对话 | Claude Opus | 0.8 | 300s |
| 大纲生成 | 结构规划 | DeepSeek-Chat | 0.7 | 360s |
| 章节正文 | 正文生成 | GPT-4o | 0.75 | 600s |
| 摘要提取 | 摘要抽取 | Gemini Flash | 0.15 | 120s |
| 基础分析 | 摘要抽取 | Gemini Flash | 0.3 | 180s |
| 增强分析 | 增强分析 | GPT-4o | 0.5 | 300s |
| 章节评估 | 创意分析 | Claude Sonnet | 0.4 | 180s |
| 卷名生成 | 结构规划 | DeepSeek-Chat | 0.7 | 30s |
| 剧情指标 | 增强分析 | GPT-4o | 0.3 | 180s |

---

## 🔧 技术实现建议

### 1. 创建独立的AI功能枚举

```python
# app/schemas/ai_function.py

from enum import Enum

class AIFunctionType(str, Enum):
    """AI功能类型"""
    # 概念阶段
    CONCEPT_GENERATION = "concept_generation"
    
    # 规划阶段
    OUTLINE_GENERATION = "outline_generation"
    
    # 写作阶段
    CHAPTER_WRITING = "chapter_writing"
    SUMMARY_EXTRACTION = "summary_extraction"
    
    # 分析阶段
    BASIC_ANALYSIS = "basic_analysis"
    ENHANCED_ANALYSIS = "enhanced_analysis"
    
    # 评估阶段
    CHAPTER_EVALUATION = "chapter_evaluation"
    
    # 基础设施
    EMBEDDING = "embedding"


class AIFunctionPriority(str, Enum):
    """AI功能优先级"""
    CRITICAL = "critical"    # 核心功能，必须成功
    IMPORTANT = "important"  # 重要功能，失败需重试
    OPTIONAL = "optional"    # 可选功能，失败可忽略
    PREMIUM = "premium"      # 增值功能，需要权限


# 功能配置映射
AI_FUNCTION_CONFIG = {
    AIFunctionType.CONCEPT_GENERATION: {
        "priority": AIFunctionPriority.IMPORTANT,
        "prompt": "concept",
        "temperature": 0.8,
        "max_retries": 2,
        "timeout": 300,
    },
    AIFunctionType.OUTLINE_GENERATION: {
        "priority": AIFunctionPriority.IMPORTANT,
        "prompt": "outline",
        "temperature": 0.7,
        "max_retries": 3,
        "timeout": 360,
    },
    AIFunctionType.CHAPTER_WRITING: {
        "priority": AIFunctionPriority.CRITICAL,
        "prompt": "writing",
        "temperature": 0.75,
        "max_retries": 3,
        "timeout": 600,
    },
    AIFunctionType.SUMMARY_EXTRACTION: {
        "priority": AIFunctionPriority.CRITICAL,
        "prompt": "extraction",
        "temperature": 0.15,
        "max_retries": 2,
        "timeout": 120,
    },
    AIFunctionType.BASIC_ANALYSIS: {
        "priority": AIFunctionPriority.CRITICAL,
        "prompt": None,  # 内嵌
        "temperature": 0.3,
        "max_retries": 2,
        "timeout": 180,
    },
    AIFunctionType.ENHANCED_ANALYSIS: {
        "priority": AIFunctionPriority.OPTIONAL,
        "prompt": None,  # 内嵌
        "temperature": 0.5,
        "max_retries": 1,
        "timeout": 300,
    },
    AIFunctionType.CHAPTER_EVALUATION: {
        "priority": AIFunctionPriority.PREMIUM,
        "prompt": "evaluation",
        "temperature": 0.4,
        "max_retries": 1,
        "timeout": 180,
    },
    AIFunctionType.EMBEDDING: {
        "priority": AIFunctionPriority.IMPORTANT,
        "prompt": None,
        "temperature": None,
        "max_retries": 2,
        "timeout": 60,
    },
}
```

### 2. 统一的AI调用接口

```python
# app/services/ai_orchestrator.py

class AIOrchestrator:
    """AI功能编排器"""
    
    async def execute(
        self,
        function_type: AIFunctionType,
        user_id: int,
        **kwargs
    ) -> dict:
        """
        统一的AI功能执行接口
        
        自动处理：
        - 配置加载
        - 重试逻辑
        - 错误处理
        - 监控记录
        - 配额检查
        """
        config = AI_FUNCTION_CONFIG[function_type]
        
        # 检查权限
        if config["priority"] == AIFunctionPriority.PREMIUM:
            if not await self._check_premium_access(user_id):
                raise PermissionError("需要高级会员")
        
        # 检查配额
        await self._check_quota(user_id, function_type)
        
        # 执行调用（带重试）
        for attempt in range(config["max_retries"]):
            try:
                result = await self._call_ai(
                    function_type=function_type,
                    config=config,
                    **kwargs
                )
                
                # 记录成功
                await self._record_success(user_id, function_type)
                return result
                
            except Exception as e:
                if attempt == config["max_retries"] - 1:
                    # 最后一次重试失败
                    await self._record_failure(user_id, function_type, e)
                    
                    # 根据优先级决定是否抛出异常
                    if config["priority"] == AIFunctionPriority.CRITICAL:
                        raise
                    else:
                        return self._get_fallback_result(function_type)
```

### 3. 独立的配置管理

```python
# 数据库表：ai_function_configs
CREATE TABLE ai_function_configs (
    id INTEGER PRIMARY KEY,
    function_type VARCHAR(50) NOT NULL UNIQUE,
    priority VARCHAR(20) NOT NULL,
    enabled BOOLEAN DEFAULT TRUE,
    temperature FLOAT,
    max_retries INTEGER,
    timeout INTEGER,
    prompt_name VARCHAR(50),
    model_override VARCHAR(100),  -- 可以为特定功能指定模型
    created_at TIMESTAMP,
    updated_at TIMESTAMP
);

# 用户级别的功能开关
CREATE TABLE user_ai_function_access (
    id INTEGER PRIMARY KEY,
    user_id INTEGER NOT NULL,
    function_type VARCHAR(50) NOT NULL,
    enabled BOOLEAN DEFAULT TRUE,
    quota_limit INTEGER,  -- 每日配额
    quota_used INTEGER DEFAULT 0,
    reset_at TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(id)
);
```

---

## 📈 监控和分析

### 为每个功能独立追踪：

```python
# Prometheus指标
ai_function_calls_total = Counter(
    'ai_function_calls_total',
    'Total AI function calls',
    ['function_type', 'status']  # success/failure
)

ai_function_duration_seconds = Histogram(
    'ai_function_duration_seconds',
    'AI function execution time',
    ['function_type']
)

ai_function_token_usage = Counter(
    'ai_function_token_usage',
    'Token usage by function',
    ['function_type', 'token_type']  # input/output
)

ai_function_cost_usd = Counter(
    'ai_function_cost_usd',
    'Estimated cost by function',
    ['function_type']
)
```

---

## 🎯 实施步骤

### 阶段1：基础拆分（1-2天）
1. 创建 `AIFunctionType` 枚举
2. 创建 `AI_FUNCTION_CONFIG` 配置
3. 在现有代码中标记每个AI调用的类型

### 阶段2：统一接口（2-3天）
1. 创建 `AIOrchestrator` 类
2. 重构现有服务使用统一接口
3. 添加重试和降级逻辑

### 阶段3：配置管理（1-2天）
1. 创建数据库表
2. 实现配置管理API
3. 添加管理后台界面

### 阶段4：监控优化（1-2天）
1. 添加详细的监控指标
2. 创建监控面板
3. 设置告警规则

---

## 💰 商业价值

### 1. 差异化定价
- 免费用户：核心功能
- 标准会员：+ 增强分析
- 高级会员：+ 章节评估 + 更高配额

### 2. 成本优化
- 为不同功能使用不同模型
- 核心功能用贵的模型（GPT-4）
- 可选功能用便宜的模型（GPT-3.5）

### 3. 性能优化
- 识别慢功能并优化
- 异步执行可选功能
- 批量处理降低成本

---

## 📝 总结

**推荐方案**: 方案A（按阶段）+ 方案C（按重要性）

**核心优势**:
1. ✅ 用户视角清晰（按创作阶段）
2. ✅ 技术实现灵活（按重要性分级）
3. ✅ 便于监控和优化
4. ✅ 支持差异化定价
5. ✅ 降级策略明确

**下一步**:
1. 确认分类方案
2. 创建枚举和配置
3. 逐步重构现有代码
4. 添加监控和管理界面
