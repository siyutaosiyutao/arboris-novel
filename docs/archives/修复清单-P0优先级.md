# 修复清单 - P0优先级（立即修复）

**创建日期**: 2025-10-30  
**优先级**: 🔴 P0 - 安全和稳定性问题

---

## 修复1: 添加管理员权限检查

### 文件
`backend/app/api/routers/ai_routing.py`

### 问题
任何登录用户都可以修改AI路由配置

### 修复代码

```python
# 1. 创建权限检查依赖
# backend/app/core/deps.py

async def require_admin(
    current_user: User = Depends(get_current_user),
) -> User:
    """要求管理员权限"""
    if not current_user.is_admin:  # 假设User模型有is_admin字段
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="需要管理员权限"
        )
    return current_user


# 2. 在API中使用
# backend/app/api/routers/ai_routing.py

from ...core.deps import require_admin

@router.patch("/routes/{function_type}")
async def update_route(
    function_type: str,
    request: UpdateRouteRequest,
    session: AsyncSession = Depends(get_session),
    current_user: User = Depends(require_admin),  # ✅ 改为require_admin
):
    """更新功能路由配置（需要管理员权限）"""
    # ...
```

### 验证
```bash
# 测试非管理员用户
curl -X PATCH http://localhost:8000/api/ai-routing/routes/chapter_content_writing \
  -H "Authorization: Bearer <non-admin-token>" \
  -d '{"temperature": 0.95}'

# 预期: 403 Forbidden
```

---

## 修复2: 修复资源泄漏（Prometheus指标）

### 文件
`backend/app/services/ai_orchestrator.py`

### 问题
如果在执行过程中抛出异常，`ai_calls_in_progress` 指标不会被减少

### 修复代码

```python
async def execute(
    self,
    function: AIFunctionType,
    system_prompt: str,
    user_prompt: str,
    *,
    temperature: Optional[float] = None,
    timeout: Optional[float] = None,
    user_id: Optional[int] = None,
    response_format: Optional[str] = "json_object",
) -> str:
    # 获取功能配置
    config = get_function_config(function)
    if not config:
        raise ValueError(f"未找到功能 {function} 的配置")

    # 使用配置中的参数
    final_temperature = temperature if temperature is not None else config.temperature
    final_timeout = timeout if timeout is not None else config.timeout

    # 构建消息
    messages = [
        {"role": "system", "content": system_prompt},
        {"role": "user", "content": user_prompt},
    ]

    logger.info(
        f"执行AI功能: {function.value}, 主模型: {config.primary.provider}/{config.primary.model}"
    )

    # ✅ 使用 try-finally 确保一定会减少计数
    ai_calls_in_progress.labels(function=function.value).inc()
    try:
        # 构建尝试列表：主模型 + 备用模型
        attempts = [config.primary] + config.fallbacks
        last_error = None
        fallback_count = 0
        start_time = time.time()

        # ... 原有的执行逻辑 ...
        
        # 如果所有模型都失败
        if config.required:
            raise last_error
        else:
            return self._get_default_response(function)
            
    finally:
        # ✅ 确保一定会执行
        ai_calls_in_progress.labels(function=function.value).dec()
```

### 验证
```python
# 测试异常情况
import pytest

@pytest.mark.asyncio
async def test_metrics_cleanup_on_error():
    orchestrator = AIOrchestrator(llm_service, db_session)
    
    # 记录初始值
    initial_value = get_metric_value("ai_calls_in_progress", function="test")
    
    # 触发异常
    with pytest.raises(Exception):
        await orchestrator.execute(...)
    
    # 验证指标已恢复
    final_value = get_metric_value("ai_calls_in_progress", function="test")
    assert final_value == initial_value
```

---

## 修复3: 修复事务边界问题

### 文件
`backend/app/services/ai_orchestrator.py`

### 问题
在 `_log_call` 方法中直接commit，可能与外部事务冲突

### 修复代码

```python
async def _log_call(
    self,
    function: AIFunctionType,
    provider: str,
    model: str,
    status: str,
    is_fallback: bool,
    fallback_count: int,
    duration_ms: int,
    user_id: Optional[int] = None,
    temperature: Optional[float] = None,
    timeout: Optional[float] = None,
    error_type: Optional[str] = None,
    error_message: Optional[str] = None,
    finish_reason: Optional[str] = None,
):
    """
    记录调用日志到数据库
    """
    if not self.log_repo:
        return

    try:
        log = AIFunctionCallLog(
            function_type=function.value,
            model=model,
            user_id=user_id,
            temperature=temperature,
            timeout_seconds=int(timeout) if timeout else None,
            status=status,
            is_fallback=is_fallback,
            fallback_count=fallback_count,
            duration_ms=duration_ms,
            error_type=error_type,
            error_message=error_message[:500] if error_message else None,
            finish_reason=finish_reason,
        )
        
        await self.log_repo.create(log)
        # ✅ 移除 commit，让调用者控制事务
        # await self.db_session.commit()  # ❌ 删除这行
        
    except Exception as e:
        logger.error(f"记录调用日志失败: {e}")
        # 不影响主流程


# ✅ 在调用处添加commit
async def execute(...):
    try:
        # ... 执行逻辑 ...
        
        # 记录成功日志
        await self._log_call(...)
        
        # ✅ 在这里commit
        if self.db_session:
            await self.db_session.commit()
        
        return response
    except Exception as e:
        # 记录失败日志
        await self._log_call(...)
        
        # ✅ 在这里commit
        if self.db_session:
            await self.db_session.commit()
        
        raise
```

### 验证
```python
# 测试事务回滚
@pytest.mark.asyncio
async def test_transaction_rollback():
    async with AsyncSessionLocal() as session:
        orchestrator = AIOrchestrator(llm_service, session)
        
        try:
            # 执行操作
            await orchestrator.execute(...)
            
            # 手动回滚
            await session.rollback()
            
            # 验证日志没有被保存
            logs = await session.execute(select(AIFunctionCallLog))
            assert len(logs.all()) == 0
        except:
            pass
```

---

## 修复4: 添加输入验证

### 文件
`backend/app/api/routers/ai_routing.py`

### 问题
更新配置时没有验证输入范围

### 修复代码

```python
from pydantic import Field, validator

class UpdateRouteRequest(BaseModel):
    primary_provider_id: Optional[int] = Field(None, gt=0)
    primary_model: Optional[str] = Field(None, min_length=1, max_length=200)
    temperature: Optional[float] = Field(None, ge=0.0, le=2.0)
    timeout_seconds: Optional[int] = Field(None, ge=1, le=3600)
    max_retries: Optional[int] = Field(None, ge=0, le=10)
    enabled: Optional[bool] = None
    
    @validator('primary_model')
    def validate_model_name(cls, v):
        if v and not v.strip():
            raise ValueError('模型名称不能为空')
        return v


@router.patch("/routes/{function_type}")
async def update_route(
    function_type: str,
    request: UpdateRouteRequest,  # ✅ Pydantic会自动验证
    session: AsyncSession = Depends(get_session),
    current_user: User = Depends(require_admin),
):
    """更新功能路由配置"""
    
    # ✅ 验证function_type
    valid_types = [t.value for t in AIFunctionType]
    if function_type not in valid_types:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"无效的功能类型: {function_type}"
        )
    
    # ... 其余逻辑
```

### 验证
```bash
# 测试无效的temperature
curl -X PATCH http://localhost:8000/api/ai-routing/routes/chapter_content_writing \
  -d '{"temperature": 5.0}'

# 预期: 422 Unprocessable Entity

# 测试无效的timeout
curl -X PATCH http://localhost:8000/api/ai-routing/routes/chapter_content_writing \
  -d '{"timeout_seconds": -1}'

# 预期: 422 Unprocessable Entity
```

---

## 修复5: 移除敏感信息暴露

### 文件
`backend/app/api/routers/ai_routing.py`

### 问题
API返回了内部API地址和成本信息

### 修复代码

```python
# ✅ 创建两个Schema：公开版和管理员版

class AIProviderPublicSchema(BaseModel):
    """公开的Provider信息"""
    id: int
    name: str
    display_name: str
    status: str
    
    class Config:
        from_attributes = True


class AIProviderAdminSchema(AIProviderPublicSchema):
    """管理员可见的完整Provider信息"""
    base_url: str
    priority: int
    cost_per_1k_tokens: Optional[float] = None
    api_key_env: Optional[str] = None


# ✅ 根据用户权限返回不同的Schema
@router.get("/providers")
async def list_providers(
    session: AsyncSession = Depends(get_session),
    current_user: User = Depends(get_current_user),
):
    """获取AI提供商列表"""
    repo = AIProviderRepository(session)
    providers = await repo.get_all_active()
    
    # ✅ 根据权限返回不同的数据
    if current_user.is_admin:
        return [AIProviderAdminSchema.from_orm(p) for p in providers]
    else:
        return [AIProviderPublicSchema.from_orm(p) for p in providers]
```

### 验证
```bash
# 普通用户
curl http://localhost:8000/api/ai-routing/providers \
  -H "Authorization: Bearer <user-token>"

# 预期: 只返回 id, name, display_name, status

# 管理员
curl http://localhost:8000/api/ai-routing/providers \
  -H "Authorization: Bearer <admin-token>"

# 预期: 返回完整信息
```

---

## 验证清单

- [ ] 修复1: 管理员权限检查
  - [ ] 代码修改完成
  - [ ] 测试非管理员访问被拒绝
  - [ ] 测试管理员访问成功

- [ ] 修复2: Prometheus指标清理
  - [ ] 代码修改完成
  - [ ] 测试异常情况下指标正确
  - [ ] 监控指标数据准确

- [ ] 修复3: 事务边界
  - [ ] 代码修改完成
  - [ ] 测试事务回滚
  - [ ] 测试并发场景

- [ ] 修复4: 输入验证
  - [ ] 代码修改完成
  - [ ] 测试无效输入被拒绝
  - [ ] 测试有效输入通过

- [ ] 修复5: 敏感信息
  - [ ] 代码修改完成
  - [ ] 测试普通用户看不到敏感信息
  - [ ] 测试管理员可以看到完整信息

---

## 预计工作量

- 修复1: 1小时
- 修复2: 1小时
- 修复3: 2小时
- 修复4: 1小时
- 修复5: 1小时

**总计**: 6小时

---

**状态**: 待修复  
**优先级**: 🔴 P0  
**截止日期**: 建议24小时内完成

