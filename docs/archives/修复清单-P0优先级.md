# ä¿®å¤æ¸…å• - P0ä¼˜å…ˆçº§ï¼ˆç«‹å³ä¿®å¤ï¼‰

**åˆ›å»ºæ—¥æœŸ**: 2025-10-30  
**ä¼˜å…ˆçº§**: ğŸ”´ P0 - å®‰å…¨å’Œç¨³å®šæ€§é—®é¢˜

---

## ä¿®å¤1: æ·»åŠ ç®¡ç†å‘˜æƒé™æ£€æŸ¥

### æ–‡ä»¶
`backend/app/api/routers/ai_routing.py`

### é—®é¢˜
ä»»ä½•ç™»å½•ç”¨æˆ·éƒ½å¯ä»¥ä¿®æ”¹AIè·¯ç”±é…ç½®

### ä¿®å¤ä»£ç 

```python
# 1. åˆ›å»ºæƒé™æ£€æŸ¥ä¾èµ–
# backend/app/core/deps.py

async def require_admin(
    current_user: User = Depends(get_current_user),
) -> User:
    """è¦æ±‚ç®¡ç†å‘˜æƒé™"""
    if not current_user.is_admin:  # å‡è®¾Useræ¨¡å‹æœ‰is_adminå­—æ®µ
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="éœ€è¦ç®¡ç†å‘˜æƒé™"
        )
    return current_user


# 2. åœ¨APIä¸­ä½¿ç”¨
# backend/app/api/routers/ai_routing.py

from ...core.deps import require_admin

@router.patch("/routes/{function_type}")
async def update_route(
    function_type: str,
    request: UpdateRouteRequest,
    session: AsyncSession = Depends(get_session),
    current_user: User = Depends(require_admin),  # âœ… æ”¹ä¸ºrequire_admin
):
    """æ›´æ–°åŠŸèƒ½è·¯ç”±é…ç½®ï¼ˆéœ€è¦ç®¡ç†å‘˜æƒé™ï¼‰"""
    # ...
```

### éªŒè¯
```bash
# æµ‹è¯•éç®¡ç†å‘˜ç”¨æˆ·
curl -X PATCH http://localhost:8000/api/ai-routing/routes/chapter_content_writing \
  -H "Authorization: Bearer <non-admin-token>" \
  -d '{"temperature": 0.95}'

# é¢„æœŸ: 403 Forbidden
```

---

## ä¿®å¤2: ä¿®å¤èµ„æºæ³„æ¼ï¼ˆPrometheusæŒ‡æ ‡ï¼‰

### æ–‡ä»¶
`backend/app/services/ai_orchestrator.py`

### é—®é¢˜
å¦‚æœåœ¨æ‰§è¡Œè¿‡ç¨‹ä¸­æŠ›å‡ºå¼‚å¸¸ï¼Œ`ai_calls_in_progress` æŒ‡æ ‡ä¸ä¼šè¢«å‡å°‘

### ä¿®å¤ä»£ç 

```python
async def execute(
    self,
    function: AIFunctionType,
    system_prompt: str,
    user_prompt: str,
    *,
    temperature: Optional[float] = None,
    timeout: Optional[float] = None,
    user_id: Optional[int] = None,
    response_format: Optional[str] = "json_object",
) -> str:
    # è·å–åŠŸèƒ½é…ç½®
    config = get_function_config(function)
    if not config:
        raise ValueError(f"æœªæ‰¾åˆ°åŠŸèƒ½ {function} çš„é…ç½®")

    # ä½¿ç”¨é…ç½®ä¸­çš„å‚æ•°
    final_temperature = temperature if temperature is not None else config.temperature
    final_timeout = timeout if timeout is not None else config.timeout

    # æ„å»ºæ¶ˆæ¯
    messages = [
        {"role": "system", "content": system_prompt},
        {"role": "user", "content": user_prompt},
    ]

    logger.info(
        f"æ‰§è¡ŒAIåŠŸèƒ½: {function.value}, ä¸»æ¨¡å‹: {config.primary.provider}/{config.primary.model}"
    )

    # âœ… ä½¿ç”¨ try-finally ç¡®ä¿ä¸€å®šä¼šå‡å°‘è®¡æ•°
    ai_calls_in_progress.labels(function=function.value).inc()
    try:
        # æ„å»ºå°è¯•åˆ—è¡¨ï¼šä¸»æ¨¡å‹ + å¤‡ç”¨æ¨¡å‹
        attempts = [config.primary] + config.fallbacks
        last_error = None
        fallback_count = 0
        start_time = time.time()

        # ... åŸæœ‰çš„æ‰§è¡Œé€»è¾‘ ...
        
        # å¦‚æœæ‰€æœ‰æ¨¡å‹éƒ½å¤±è´¥
        if config.required:
            raise last_error
        else:
            return self._get_default_response(function)
            
    finally:
        # âœ… ç¡®ä¿ä¸€å®šä¼šæ‰§è¡Œ
        ai_calls_in_progress.labels(function=function.value).dec()
```

### éªŒè¯
```python
# æµ‹è¯•å¼‚å¸¸æƒ…å†µ
import pytest

@pytest.mark.asyncio
async def test_metrics_cleanup_on_error():
    orchestrator = AIOrchestrator(llm_service, db_session)
    
    # è®°å½•åˆå§‹å€¼
    initial_value = get_metric_value("ai_calls_in_progress", function="test")
    
    # è§¦å‘å¼‚å¸¸
    with pytest.raises(Exception):
        await orchestrator.execute(...)
    
    # éªŒè¯æŒ‡æ ‡å·²æ¢å¤
    final_value = get_metric_value("ai_calls_in_progress", function="test")
    assert final_value == initial_value
```

---

## ä¿®å¤3: ä¿®å¤äº‹åŠ¡è¾¹ç•Œé—®é¢˜

### æ–‡ä»¶
`backend/app/services/ai_orchestrator.py`

### é—®é¢˜
åœ¨ `_log_call` æ–¹æ³•ä¸­ç›´æ¥commitï¼Œå¯èƒ½ä¸å¤–éƒ¨äº‹åŠ¡å†²çª

### ä¿®å¤ä»£ç 

```python
async def _log_call(
    self,
    function: AIFunctionType,
    provider: str,
    model: str,
    status: str,
    is_fallback: bool,
    fallback_count: int,
    duration_ms: int,
    user_id: Optional[int] = None,
    temperature: Optional[float] = None,
    timeout: Optional[float] = None,
    error_type: Optional[str] = None,
    error_message: Optional[str] = None,
    finish_reason: Optional[str] = None,
):
    """
    è®°å½•è°ƒç”¨æ—¥å¿—åˆ°æ•°æ®åº“
    """
    if not self.log_repo:
        return

    try:
        log = AIFunctionCallLog(
            function_type=function.value,
            model=model,
            user_id=user_id,
            temperature=temperature,
            timeout_seconds=int(timeout) if timeout else None,
            status=status,
            is_fallback=is_fallback,
            fallback_count=fallback_count,
            duration_ms=duration_ms,
            error_type=error_type,
            error_message=error_message[:500] if error_message else None,
            finish_reason=finish_reason,
        )
        
        await self.log_repo.create(log)
        # âœ… ç§»é™¤ commitï¼Œè®©è°ƒç”¨è€…æ§åˆ¶äº‹åŠ¡
        # await self.db_session.commit()  # âŒ åˆ é™¤è¿™è¡Œ
        
    except Exception as e:
        logger.error(f"è®°å½•è°ƒç”¨æ—¥å¿—å¤±è´¥: {e}")
        # ä¸å½±å“ä¸»æµç¨‹


# âœ… åœ¨è°ƒç”¨å¤„æ·»åŠ commit
async def execute(...):
    try:
        # ... æ‰§è¡Œé€»è¾‘ ...
        
        # è®°å½•æˆåŠŸæ—¥å¿—
        await self._log_call(...)
        
        # âœ… åœ¨è¿™é‡Œcommit
        if self.db_session:
            await self.db_session.commit()
        
        return response
    except Exception as e:
        # è®°å½•å¤±è´¥æ—¥å¿—
        await self._log_call(...)
        
        # âœ… åœ¨è¿™é‡Œcommit
        if self.db_session:
            await self.db_session.commit()
        
        raise
```

### éªŒè¯
```python
# æµ‹è¯•äº‹åŠ¡å›æ»š
@pytest.mark.asyncio
async def test_transaction_rollback():
    async with AsyncSessionLocal() as session:
        orchestrator = AIOrchestrator(llm_service, session)
        
        try:
            # æ‰§è¡Œæ“ä½œ
            await orchestrator.execute(...)
            
            # æ‰‹åŠ¨å›æ»š
            await session.rollback()
            
            # éªŒè¯æ—¥å¿—æ²¡æœ‰è¢«ä¿å­˜
            logs = await session.execute(select(AIFunctionCallLog))
            assert len(logs.all()) == 0
        except:
            pass
```

---

## ä¿®å¤4: æ·»åŠ è¾“å…¥éªŒè¯

### æ–‡ä»¶
`backend/app/api/routers/ai_routing.py`

### é—®é¢˜
æ›´æ–°é…ç½®æ—¶æ²¡æœ‰éªŒè¯è¾“å…¥èŒƒå›´

### ä¿®å¤ä»£ç 

```python
from pydantic import Field, validator

class UpdateRouteRequest(BaseModel):
    primary_provider_id: Optional[int] = Field(None, gt=0)
    primary_model: Optional[str] = Field(None, min_length=1, max_length=200)
    temperature: Optional[float] = Field(None, ge=0.0, le=2.0)
    timeout_seconds: Optional[int] = Field(None, ge=1, le=3600)
    max_retries: Optional[int] = Field(None, ge=0, le=10)
    enabled: Optional[bool] = None
    
    @validator('primary_model')
    def validate_model_name(cls, v):
        if v and not v.strip():
            raise ValueError('æ¨¡å‹åç§°ä¸èƒ½ä¸ºç©º')
        return v


@router.patch("/routes/{function_type}")
async def update_route(
    function_type: str,
    request: UpdateRouteRequest,  # âœ… Pydanticä¼šè‡ªåŠ¨éªŒè¯
    session: AsyncSession = Depends(get_session),
    current_user: User = Depends(require_admin),
):
    """æ›´æ–°åŠŸèƒ½è·¯ç”±é…ç½®"""
    
    # âœ… éªŒè¯function_type
    valid_types = [t.value for t in AIFunctionType]
    if function_type not in valid_types:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"æ— æ•ˆçš„åŠŸèƒ½ç±»å‹: {function_type}"
        )
    
    # ... å…¶ä½™é€»è¾‘
```

### éªŒè¯
```bash
# æµ‹è¯•æ— æ•ˆçš„temperature
curl -X PATCH http://localhost:8000/api/ai-routing/routes/chapter_content_writing \
  -d '{"temperature": 5.0}'

# é¢„æœŸ: 422 Unprocessable Entity

# æµ‹è¯•æ— æ•ˆçš„timeout
curl -X PATCH http://localhost:8000/api/ai-routing/routes/chapter_content_writing \
  -d '{"timeout_seconds": -1}'

# é¢„æœŸ: 422 Unprocessable Entity
```

---

## ä¿®å¤5: ç§»é™¤æ•æ„Ÿä¿¡æ¯æš´éœ²

### æ–‡ä»¶
`backend/app/api/routers/ai_routing.py`

### é—®é¢˜
APIè¿”å›äº†å†…éƒ¨APIåœ°å€å’Œæˆæœ¬ä¿¡æ¯

### ä¿®å¤ä»£ç 

```python
# âœ… åˆ›å»ºä¸¤ä¸ªSchemaï¼šå…¬å¼€ç‰ˆå’Œç®¡ç†å‘˜ç‰ˆ

class AIProviderPublicSchema(BaseModel):
    """å…¬å¼€çš„Providerä¿¡æ¯"""
    id: int
    name: str
    display_name: str
    status: str
    
    class Config:
        from_attributes = True


class AIProviderAdminSchema(AIProviderPublicSchema):
    """ç®¡ç†å‘˜å¯è§çš„å®Œæ•´Providerä¿¡æ¯"""
    base_url: str
    priority: int
    cost_per_1k_tokens: Optional[float] = None
    api_key_env: Optional[str] = None


# âœ… æ ¹æ®ç”¨æˆ·æƒé™è¿”å›ä¸åŒçš„Schema
@router.get("/providers")
async def list_providers(
    session: AsyncSession = Depends(get_session),
    current_user: User = Depends(get_current_user),
):
    """è·å–AIæä¾›å•†åˆ—è¡¨"""
    repo = AIProviderRepository(session)
    providers = await repo.get_all_active()
    
    # âœ… æ ¹æ®æƒé™è¿”å›ä¸åŒçš„æ•°æ®
    if current_user.is_admin:
        return [AIProviderAdminSchema.from_orm(p) for p in providers]
    else:
        return [AIProviderPublicSchema.from_orm(p) for p in providers]
```

### éªŒè¯
```bash
# æ™®é€šç”¨æˆ·
curl http://localhost:8000/api/ai-routing/providers \
  -H "Authorization: Bearer <user-token>"

# é¢„æœŸ: åªè¿”å› id, name, display_name, status

# ç®¡ç†å‘˜
curl http://localhost:8000/api/ai-routing/providers \
  -H "Authorization: Bearer <admin-token>"

# é¢„æœŸ: è¿”å›å®Œæ•´ä¿¡æ¯
```

---

## éªŒè¯æ¸…å•

- [ ] ä¿®å¤1: ç®¡ç†å‘˜æƒé™æ£€æŸ¥
  - [ ] ä»£ç ä¿®æ”¹å®Œæˆ
  - [ ] æµ‹è¯•éç®¡ç†å‘˜è®¿é—®è¢«æ‹’ç»
  - [ ] æµ‹è¯•ç®¡ç†å‘˜è®¿é—®æˆåŠŸ

- [ ] ä¿®å¤2: PrometheusæŒ‡æ ‡æ¸…ç†
  - [ ] ä»£ç ä¿®æ”¹å®Œæˆ
  - [ ] æµ‹è¯•å¼‚å¸¸æƒ…å†µä¸‹æŒ‡æ ‡æ­£ç¡®
  - [ ] ç›‘æ§æŒ‡æ ‡æ•°æ®å‡†ç¡®

- [ ] ä¿®å¤3: äº‹åŠ¡è¾¹ç•Œ
  - [ ] ä»£ç ä¿®æ”¹å®Œæˆ
  - [ ] æµ‹è¯•äº‹åŠ¡å›æ»š
  - [ ] æµ‹è¯•å¹¶å‘åœºæ™¯

- [ ] ä¿®å¤4: è¾“å…¥éªŒè¯
  - [ ] ä»£ç ä¿®æ”¹å®Œæˆ
  - [ ] æµ‹è¯•æ— æ•ˆè¾“å…¥è¢«æ‹’ç»
  - [ ] æµ‹è¯•æœ‰æ•ˆè¾“å…¥é€šè¿‡

- [ ] ä¿®å¤5: æ•æ„Ÿä¿¡æ¯
  - [ ] ä»£ç ä¿®æ”¹å®Œæˆ
  - [ ] æµ‹è¯•æ™®é€šç”¨æˆ·çœ‹ä¸åˆ°æ•æ„Ÿä¿¡æ¯
  - [ ] æµ‹è¯•ç®¡ç†å‘˜å¯ä»¥çœ‹åˆ°å®Œæ•´ä¿¡æ¯

---

## é¢„è®¡å·¥ä½œé‡

- ä¿®å¤1: 1å°æ—¶
- ä¿®å¤2: 1å°æ—¶
- ä¿®å¤3: 2å°æ—¶
- ä¿®å¤4: 1å°æ—¶
- ä¿®å¤5: 1å°æ—¶

**æ€»è®¡**: 6å°æ—¶

---

**çŠ¶æ€**: å¾…ä¿®å¤  
**ä¼˜å…ˆçº§**: ğŸ”´ P0  
**æˆªæ­¢æ—¥æœŸ**: å»ºè®®24å°æ—¶å†…å®Œæˆ

